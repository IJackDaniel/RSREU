# Предмет: Основы систем искусственного интеллекта
# Предметная область: робот в лабиринте
# Работу выполнил: студент группы 3413 - Афонин Даниил Олегович
# Дата начала выполнения работы: 05.10.2024

# Добавление необходимых библиотек
from time import sleep
from functools import cmp_to_key


class Situation:
    def __init__(self, maze, current_coord, target):
        self.maze = maze  # Лабиринт, представленный в виде матрицы
        self.coord = current_coord  # Действующие координаты робота в виде массива из двух значений
        self.target = target  # Целевая координата в виде массива из двух значений

    # Функция проверки целевой ситуации
    def target_situation(self, arr):  # На вход подаётся ситуация
        x, y = arr[0], arr[1]
        return x == self.target[0] and y == self.target[1]  # Выход - результат проверки

    # Функция определения тупика/стенки
    def wall(self, arr):  # На вход подаётся ситуация
        return self.maze[arr[0]][arr[1]] == "2"  # Выход - результат проверки

    # Функция отображения действующей ситуации
    def show_current_situation(self, arr, flag, path=None):  # на вход подаётся ситуация
        if path is None:
            path = []
        if not flag:
            print(arr[0], arr[1])
        matrix = self.maze  # Лабиринт
        n = len(matrix)  # Длина лабиринта
        m = len(matrix[0])  # Ширина лабиринта

        for i in range(n):
            for j in range(m):
                current = [i, j]
                if current == arr:  # Проверка координаты на координаты робота
                    print("R", end=" ")
                elif current == self.target:  # Проверка координаты на цель
                    print("x", end=" ")
                elif self.maze[i][j] == "2":  # Проверка координаты на стенку
                    print(chr(9608), end=" ")
                elif current in path:
                    print("1", end=" ")
                else:
                    print(self.maze[i][j], end=" ")
            print()
        print()

    # Оценочная функция по градиенту
    # производит сравнение ситуаций
    def valuation_method(self, *situations):  # на вход подаётся набор ситуаций
        situation_1, situation_2 = situations[0], situations[1]
        # Сравнение ситуаций с целевой
        if ((situation_1[0][0] - self.target[0]) ** 2 + (situation_1[0][1] - self.target[1]) ** 2 <=
                (situation_2[0][0] - self.target[0]) ** 2 + (situation_2[0][1] - self.target[1]) ** 2):
            return -1  # Если первая ситуация хуже
        else:
            return 1  # Если первая ситуация лучше или такая же

    # Порождающая функция
    def generate_method(self, arr):  # на вход подаётся ситуация и номер хода
        i, j, n = arr[0][0], arr[0][1], arr[1][0]
        variants = []  # возможные ходы
        for el in [[i, j + 1], [0]], [[i + 1, j], [0]], [[i - 1, j], [0]], [[i, j - 1], [0]]:
            if el[0][0] < 0 or el[0][0] > 9 or el[0][1] < 0 or el[0][1] > 9 or self.wall([el[0][0], el[0][1]]):
                continue
            else:
                variants.append(el)

        # variants.sort(key=cmp_to_key(self.valuation_method))

        if n < len(variants):
            return variants[n]  # Возврат одного хода
        else:
            return []  # Нового шага нет

    # Метод поиска в глубину
    # Вход: начальная ситуация
    # Промежуточные данные:
    # stack - стек со всеми ситуациями на пути
    # success - булева переменная, которая хранит результат проверки ситуации на целевую
    # new_situation - новая порождаемая ситуация
    # Выход: путь, который проделал робот для достижения цели
    def dfs(self):
        stack = [[self.coord, [0]]]  # Стек для хранения ситуаций
        # Цикл, пока стек не пустой
        while stack:
            success = self.target_situation(stack[-1][0])  # Проверка на достижение целевой ситуации
            # self.show_current_situation(stack[-1][0], False)  # Отображение лабиринта, робота и цели
            # sleep(0.5)  # Задержка вывода на 0,5 секунд

            # Проверка на достижение цели
            if success:
                # Перемещение значений из stack в path
                path = []
                for i in range(len(stack)):
                    path.append(stack[i][0])
                # Вывод пройденного пути
                print(f"Пройденный путь:\n{path}")
                print("Путь:")
                self.show_current_situation(stack[-1][0], True, path)
                return

            # Формирование новой ситуации
            new_situation = self.generate_method(stack[-1])

            # Проверка: попадает ли порождённая ситуация в стек
            try:
                if any(last_situation[0][0:2] == new_situation[0][0:2] for last_situation in stack):
                    stack[-1][1][0] += 1
                    continue
            except IndexError:
                pass

            # Если новых ходов больше нет
            if len(new_situation) == 0:
                stack.pop()
                # Если стек оказался пустым
                if len(stack) == 0:
                    break
                stack[-1][1][0] += 1  # Увеличиваем номер хода на 1
            else:  # Если ходы есть
                stack.append(new_situation)
        # Вывод сообщения, если решение не найдено
        print("Решения нет")
        return


if __name__ == "__main__":
    # Лабиринты (2 - стенка; 0 - ничего)

    # Первый лабиринт - коридорный
    # В этом лабиринте нет никаких разветвлений
    first_maze = [
            ["0", "0", "0", "0", "0", "0", "0", "0", "2", "0"],
            ["0", "2", "2", "2", "2", "2", "2", "0", "2", "0"],
            ["0", "0", "0", "0", "0", "0", "2", "0", "2", "0"],
            ["2", "2", "2", "2", "2", "0", "2", "0", "2", "0"],
            ["2", "0", "0", "0", "2", "0", "2", "0", "2", "0"],
            ["0", "0", "2", "0", "2", "0", "2", "0", "2", "0"],
            ["0", "2", "2", "0", "2", "0", "2", "0", "2", "0"],
            ["0", "2", "0", "0", "2", "0", "2", "0", "2", "0"],
            ["0", "2", "2", "2", "2", "0", "2", "0", "2", "0"],
            ["0", "0", "0", "0", "0", "0", "2", "0", "0", "0"]]
    # Второй лабиринт
    second_maze = [
            ["0", "2", "0", "2", "0", "2", "0", "0", "0", "0"],
            ["0", "2", "0", "0", "0", "2", "2", "2", "0", "2"],
            ["0", "0", "0", "2", "0", "2", "0", "2", "0", "2"],
            ["2", "2", "2", "2", "0", "2", "0", "2", "0", "0"],
            ["0", "2", "0", "0", "0", "2", "0", "0", "0", "2"],
            ["0", "2", "0", "2", "2", "2", "2", "2", "0", "2"],
            ["0", "0", "0", "2", "0", "2", "0", "0", "0", "2"],
            ["2", "2", "0", "0", "0", "0", "0", "0", "2", "2"],
            ["0", "2", "0", "2", "2", "0", "2", "0", "2", "0"],
            ["0", "0", "0", "2", "0", "0", "2", "0", "0", "0"]]
    # Третий лабиринт
    third_maze = [
            ["0", "2", "0", "2", "0", "2", "0", "0", "0", "0"],
            ["0", "2", "0", "0", "0", "2", "2", "2", "0", "2"],
            ["0", "0", "0", "2", "0", "2", "0", "2", "0", "2"],
            ["2", "2", "2", "2", "0", "2", "0", "2", "0", "0"],
            ["0", "2", "0", "0", "0", "2", "0", "0", "0", "2"],
            ["0", "2", "0", "2", "2", "2", "2", "2", "0", "2"],
            ["0", "0", "0", "2", "0", "2", "0", "0", "0", "2"],
            ["2", "2", "0", "0", "0", "0", "0", "0", "2", "2"],
            ["0", "2", "0", "2", "2", "0", "2", "0", "2", "0"],
            ["0", "0", "0", "2", "0", "0", "2", "0", "0", "0"]]
    # Четвёртый лабиринт - пустой
    # В этом лабиринте вообще нет стенок
    fourth_maze = [
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"]]

    # Выбор лабиринта пользователем
    print("""Выбор лабиринта:
    1. Коридорный лабиринт
    2. Первый стандартный лабиринт вариант 1
    3. Первый стандартный лабиринт вариант 2
    4. Пустой лабиринт\n""")
    choice_maze = int(input("Ввод: "))

    # Конструкция выбора лабиринта
    match choice_maze:
        case 1:
            selected_maze = first_maze
            start_pos = [0, 9]
            target_pos = [7, 2]
        case 2:
            selected_maze = second_maze
            start_pos = [2, 0]
            target_pos = [2, 6]
        case 3:
            selected_maze = third_maze
            start_pos = [0, 9]
            target_pos = [0, 2]
        case 4:
            selected_maze = fourth_maze
            start_pos = [1, 1]
            target_pos = [5, 8]
        case _:
            print("Некорректный выбор лабиринта!")
            exit(2)

    # Определение ситуации
    situation = Situation(selected_maze, start_pos, target_pos)

    # Запуск метода поиска в глубину
    situation.dfs()

'''
[
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"]]
'''